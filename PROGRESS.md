# WASM Packet Codec Implementation Progress

## Overview
Implementing WASM-based packet encoding/decoding to replace manual TypeScript CBOR encoding. This ensures consistency between Rust backend and JavaScript frontend.

## Completed Tasks

### 1. WASM Crate Creation (✓)
- Created `libraries/packet_wasm/` crate
- Added to workspace in `libraries/Cargo.toml`
- Dependencies: wasm-bindgen, serde-json, console_error_panic_hook
- Set crate-type to ["cdylib", "rlib"]

### 2. Encode/Decode Implementation (✓)
- `encode_packet(json: &str) -> Result<Vec<u8>, JsValue>`: JSON → CBOR
- `decode_packet(bytes: &[u8]) -> Result<String, JsValue>`: CBOR → JSON
- Uses existing `packet_encoding::encode_packet()` and `packet_encoding::decode_packet()`
- Uses `PacketFormat<PacketData>` type from topics crate

### 3. Testing (✓)
- Added roundtrip test: JSON → CBOR → JSON
- Test passes with ClockRequest packet
- Verified CBOR encoding/decoding works correctly

### 4. WASM Build (✓)
- Installed wasm-pack v0.13.1
- Built WASM module with: `wasm-pack build --target bundler --out-dir ../../web_interface/my-app/src/wasm libraries/packet_wasm`
- Generated files in `web_interface/my-app/src/wasm/`:
  - packet_wasm.js (glue code)
  - packet_wasm_bg.wasm (binary)
  - packet_wasm.d.ts (TypeScript definitions)
  - package.json

## Key Discoveries

### Packet Encoding API
- Function: `packet_encoding::encode_packet(message: &impl Serialize, buffer: &mut [u8]) -> Result<usize, PacketEncodeErr>`
- Returns the size of encoded data, not a slice
- Need to extract `buffer[..size]` to get actual bytes

### Packet Decoding API
- Function: `packet_encoding::decode_packet<T: Deserialize>(data: &mut [u8]) -> Result<T, PacketDecodeErr>`
- Mutates input buffer (COBS decode_in_place)
- Need to create mutable copy of input bytes

### Packet Format
- Generic: `PacketFormat<T>` where T is the data type
- Concrete type used: `PacketFormat<PacketData>`
- `PacketData` is an enum generated by `packet_data_enum!` macro

### WASM-bindgen Types
- `Vec<u8>` → `Uint8Array` (automatic conversion)
- `&[u8]` → `Uint8Array` (automatic conversion)
- `String` → `string` (automatic conversion)
- `Result<T, JsValue>` → throws JS exception on error

## Next Steps

### 5. Vite Configuration
- Check if vite-plugin-wasm needed (modern Vite might support WASM natively)
- May need to configure optimizeDeps

### 6. TypeScript Wrapper
- Create usePacketCodec.ts hook
- Initialize WASM module
- Provide type-safe wrapper around encode_packet/decode_packet

### 7. Integration
- Update useWebSocket.ts
- Update useHostConnection.ts
- Fix MotionTargetRequest in PositionPlot.tsx

### 8. Testing
- Test with actual robot
- Verify motion_controller receives packets correctly

## Notes
- WASM module size: ~40KB (optimized)
- Build time: ~5 seconds
- No external dependencies needed in browser
